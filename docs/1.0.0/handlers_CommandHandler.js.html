<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    
    <link rel="icon" href="https://george-801.github.io/webstuff/lgRed.png" />
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      handlers/CommandHandler.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="1871787" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=7946589><div class="accordion-heading child"><a href="CommandHandler.html">CommandHandler</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="CommandHandler.html#.addCommandDirectory">addCommandDirectory</a></li><li data-type='method'><a href="CommandHandler.html#.attachClient">attachClient</a></li><li data-type='method'><a href="CommandHandler.html#.generateStructure">generateStructure</a></li><li data-type='method'><a href="CommandHandler.html#.getCommand">getCommand</a></li><li data-type='method'><a href="CommandHandler.html#.getGuildCommand">getGuildCommand</a></li><li data-type='method'><a href="CommandHandler.html#.loadCommands">loadCommands</a></li><li data-type='method'><a href="CommandHandler.html#.removeCommandDirectory">removeCommandDirectory</a></li></ul></li><li class="accordion collapsed child" id=2802624><div class="accordion-heading child"><a href="DatabaseHandler.html">DatabaseHandler</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="DatabaseHandler.html#.init">init</a></li><li data-type='method'><a href="DatabaseHandler.html#.operation">operation</a></li></ul></li><li class="accordion collapsed child" id=9593635><div class="accordion-heading child"><a href="EventHandler.html">EventHandler</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="EventHandler.html#.addEventDirectory">addEventDirectory</a></li><li data-type='method'><a href="EventHandler.html#.attachClient">attachClient</a></li><li data-type='method'><a href="EventHandler.html#.loadEvents">loadEvents</a></li><li data-type='method'><a href="EventHandler.html#.removeEventDirectory">removeEventDirectory</a></li></ul></li><li class="accordion collapsed child" id=749940><div class="accordion-heading child"><a href="InteractionHandler.html">InteractionHandler</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="InteractionHandler.html#.processInteraction">processInteraction</a></li></ul></li><li class="accordion collapsed child" id=259371><div class="accordion-heading child"><a href="LanguageHandler.html">LanguageHandler</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LanguageHandler.html#.addLanguageFolder">addLanguageFolder</a></li><li data-type='method'><a href="LanguageHandler.html#.getCommandLocalisations">getCommandLocalisations</a></li><li data-type='method'><a href="LanguageHandler.html#.getCommandOptionLocalisations">getCommandOptionLocalisations</a></li><li data-type='method'><a href="LanguageHandler.html#.getLocalisation">getLocalisation</a></li><li data-type='method'><a href="LanguageHandler.html#.getLocalisationFromAPILocale">getLocalisationFromAPILocale</a></li><li data-type='method'><a href="LanguageHandler.html#.loadAllLanguages">loadAllLanguages</a></li><li data-type='method'><a href="LanguageHandler.html#.loadLanguageFile">loadLanguageFile</a></li></ul></li><li class="accordion collapsed child" id=4507637><div class="accordion-heading child"><a href="LoggingHandler.html">LoggingHandler</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LoggingHandler.html#.createLogger">createLogger</a></li></ul></li><li class="accordion collapsed child" id=1137332><div class="accordion-heading child"><a href="Util.html">Util</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Util.html#.arrayToConsoleList">arrayToConsoleList</a></li><li data-type='method'><a href="Util.html#.ownerCheck">ownerCheck</a></li><li data-type='method'><a href="Util.html#.walk">walk</a></li></ul></li></ul> </div><div class="accordion collapsed" id="5708931" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#Command">Command</a></li><li class="accordion-list" id=""><a href="global.html#CommandExecute">CommandExecute</a></li><li class="accordion-list" id=""><a href="global.html#CommandLocalisationObject">CommandLocalisationObject</a></li><li class="accordion-list" id=""><a href="global.html#CommandOption">CommandOption</a></li><li class="accordion-list" id=""><a href="global.html#CommandOptionChoice">CommandOptionChoice</a></li><li class="accordion-list" id=""><a href="global.html#CommandOptionLocalisationObject">CommandOptionLocalisationObject</a></li><li class="accordion-list" id=""><a href="global.html#CommandOptionType">CommandOptionType</a></li><li class="accordion-list" id=""><a href="global.html#CommandOptionTypes">CommandOptionTypes</a></li><li class="accordion-list" id=""><a href="global.html#CommandRole">CommandRole</a></li><li class="accordion-list" id=""><a href="global.html#CommandRoles">CommandRoles</a></li><li class="accordion-list" id=""><a href="global.html#CommandSettings">CommandSettings</a></li><li class="accordion-list" id=""><a href="global.html#CommandType">CommandType</a></li><li class="accordion-list" id=""><a href="global.html#CommandTypes">CommandTypes</a></li><li class="accordion-list" id=""><a href="global.html#Event">Event</a></li><li class="accordion-list" id=""><a href="global.html#EventDebounceSettingsObject">EventDebounceSettingsObject</a></li><li class="accordion-list" id=""><a href="global.html#EventSettingsObject">EventSettingsObject</a></li><li class="accordion-list" id=""><a href="global.html#ISOLangCode">ISOLangCode</a></li><li class="accordion-list" id=""><a href="global.html#Language">Language</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        handlers/CommandHandler.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const { Collection } = require("discord.js");
const { SlashCommandBuilder, SlashCommandSubcommandGroupBuilder, SlashCommandSubcommandBuilder } = require("@discordjs/builders");
const { getLocalisation: getText, getCommandLocalisations, getCommandOptionLocalisations } = require("./LanguageHandler")
const { isAbsolute, normalize, resolve, extname, dirname, basename } = require("path");
const { existsSync, statSync, readdirSync } = require("fs");
const { debug, warn, error, info } = require("./LoggingHandler");
const { CommandTypes, CommandRoles, CommandOptionTypes } = require("../types");
const { v4: uuidv4 } = require("uuid");
const { arrayToConsoleList } = require("../util");

/**
 * A class that handles loading, registering and running slash commands.
 */
class CommandHandler {
    /**
     * Collection containing all commands.
     * @type {Collection&lt;String, import("../types").Command>}
     * @static
     */
    static commands = new Collection();

    /**
     * Filepaths to folders containing commands.
     * @type {String[]}
     * @static
     * @private
     */
    static #directories = [];
    
    /**
     * The Discord client the CommandHandler works with.
     * @type {import("discord.js").Client}
     * @static
     * @private
     */
    static #client;

    /**
     * Attach a client to the CommandHandler.
     * @param {import("discord.js").Client} client The Discord client to attach. 
     * @returns {CommandHandler} A reference to the CommandHandler class.
     * @static
     */
    static attachClient(client) {
        CommandHandler.#client = client;
        return CommandHandler;
    }

    /**
     * Add a directory to scan for commands.
     * @param {String} dir The absolute path of the directory to add.
     * @returns {CommandHandler} A reference to the CommandHandler class.
     * @static
     * @example
     * // Adds the directory "commands" to the command handler.
     * 
     * const { join } = require("path");
     * 
     * CommandHandler.addCommandDirectory(join(__dirname, "commands"));
     */
    static addCommandDirectory(dir) {
        // if no client attached
        if (!CommandHandler.#client) throw new Error(getText(undefined, ["generic", "errors", "noClient"]));
        // return if no dir to add
        if (!dir) return CommandHandler;
        debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "addDirAttempt"], dir));
        // check path is absolute
        if (!isAbsolute(dir)) throw new Error(getText(CommandHandler.#client.consoleLang, ["generic", "errors", "path", "notAbsolute"], dir));
        // check path exists
        if (!existsSync(dir)) throw new Error(getText(CommandHandler.#client.consoleLang, ["generic", "errors", "path", "doesNotExist"], dir));
        // check path is a directory
        if (!statSync(dir).isDirectory()) throw new Error(getText(CommandHandler.#client.consoleLang, ["generic", "errors", "directory", "invalid"], dir));
        // add path to directories
        CommandHandler.#directories.push(normalize(dir));
        debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "addedDir"], dir));
        // return reference to CommandHandler
        return CommandHandler;
    }

    /**
     * Remove a directory to scan for commands.
     * @param {String} dir The absolute path of the directory to remove.
     * @returns {CommandHandler} A reference to the CommandHandler class.
     * @static
     * @example
     * // Removes the directory "commands" from the command handler.
     * 
     * const { join } = require("path");
     * 
     * CommandHandler.removeCommandDirectory(join(__dirname, "commands"));
     */
    static removeCommandDirectory(dir) {
        // if no client attached
        if (!CommandHandler.#client) throw new Error(getText(undefined, ["generic", "errors", "noClient"]));
        // return if no dir to remove
        if (!dir) return CommandHandler;
        // return if dir not contained
        if (!this.#directories.includes(normalize(dir))) return CommandHandler;
        debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "removeDirAttempt"], dir));
        // else remove the dir
        CommandHandler.#directories.splice(CommandHandler.#directories.indexOf(normalize(dir)), 1);
        debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "removedDir"], dir));
        // return reference to CommandHandler
        return CommandHandler;
    }

    /**
     * Load all commands.
     * @returns {CommandHandler} A reference to the CommandHandler class.
     * @static
     * @example
     * // Load all commands in the directory "commands"
     * 
     * const { join } = require("path");
     * 
     * CommandHandler.addCommandDirectory(join(__dirname, "commands"));
     * CommandHandler.loadCommands();
     */
    static loadCommands() {
        // if no client attached
        if (!CommandHandler.#client) throw new Error(getText(undefined, ["generic", "errors", "noClient"]));
        
        debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "loadingCommands"]));

        // reset commands
        CommandHandler.commands = new Collection();
        // test for directories that contain each other
        let overlapTest = CommandHandler.#directories.map(x => normalize(x));
        if (overlapTest.some((x, i, a) => a.some(y => y != x &amp;&amp; y.includes(x)))) warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "overlappingDirectories"]));
        // loop through directories
        for (const directory of CommandHandler.#directories) {
            debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "loadingFromDirectory"], directory));
            // get folders within the directory
            let types = readdirSync(directory);
            // filter the folders to find the types of command folders
            types = types.filter(x => statSync(resolve(directory, x)).isDirectory()).map(x => x.toUpperCase()).filter(x => CommandTypes[x] !== undefined).map(x => CommandTypes[x]);
            // skip if none found
            if (!types.length) {
                debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "noCommandsFound"], directory));
                continue;
            }
            // fancy message with info
            debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", types.includes(CommandTypes.GLOBAL) ? types.includes(CommandTypes.GUILD) ? "loadingFolderGlobalAndGuild" : "loadingFolderGlobal" : "loadingFolderGuild"]));
            // RIGHT THEN IT'S GO TIMEEEEEEEEEEEEE
            let toRegister = [];
            if (types.includes(CommandTypes.GLOBAL)) {
                // global commands dir
                let toSearch = resolve(directory, "global");
                // top level - solo commands and headers for subcommands
                let topLevelCommands = readdirSync(toSearch).map(x => resolve(toSearch, x)).filter(x => !statSync(x).isDirectory());
                // filter out non js files
                topLevelCommands = topLevelCommands.filter(x => extname(x) == ".js");
                // for each top level command
                for (const commandPath of topLevelCommands) {
                    try {
                        // delete cached files
                        delete require.cache[require.resolve(commandPath)];
                        /** @type {import("../types").Command} */
                        const command = require(commandPath);
                        // check for a command name
                        if (!command.name) {
                            warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "noName"], commandPath));
                            continue;
                        }
                        // set the command's role (for subcommand structure)
                        if (!command.execute) command.role = CommandRoles.CONTAINER;
                        else command.role = CommandRoles.COMMAND;
                        // set description
                        if (!command.description) command.description = "No description set.";
                        // perms stuff
                        if (!command.botPerms) command.botPerms = [];
                        if (!command.userPerms) command.userPerms = [];
                        // check for options
                        if (!command.options) command.options = [];
                        // file path
                        command.filePath = commandPath;
                        // unique id (for structure calculation later)
                        command.id = uuidv4();
                        // add to commands to register
                        toRegister.push(command);
                        debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "loadedTopLevelCommand"], command.name));
                    } catch (e) {
                        error(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "error", "cannotLoad"], commandPath, e.stack));
                    }
                }
            }
            // guild specific commands
            if (types.includes(CommandTypes.GUILD)) {
                // directory to search
                let toSearch = resolve(directory, "guild");
                // each guild id (folder name)
                let guilds = readdirSync(toSearch);
                // for each guild id
                for (const g of guilds) {
                    // search for specific guild
                    let toSearch = resolve(directory, "guild", g);
                    // top level - solo commands and headers for subcommands
                    let topLevelCommands = readdirSync(toSearch).map(x => resolve(toSearch, x)).filter(x => !statSync(x).isDirectory());
                    // filter out non js files
                    topLevelCommands = topLevelCommands.filter(x => extname(x) == ".js");
                    // for each command path
                    for (const commandPath of topLevelCommands) {
                        try {
                            // delete cached files
                            delete require.cache[require.resolve(commandPath)];
                            /** @type {import("../types").Command} */
                            const command = require(commandPath);
                            // check for a command name
                            if (!command.name) {
                                warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "noName"], commandPath));
                                continue;
                            }
                            // set the command's role (for subcommand structure)
                            if (!command.execute) command.role = CommandRoles.CONTAINER;
                            else command.role = CommandRoles.COMMAND;
                            // set description
                            if (!command.description) command.description = "No description set.";
                            // perms stuff
                            if (!command.botPerms) command.botPerms = [];
                            if (!command.userPerms) command.userPerms = [];
                            // check for options
                            if (!command.options) command.options = [];
                            // guild the command belongs to
                            command.guild = g;
                            // file path
                            command.filePath = commandPath;
                            // unique id (for structure calculation later)
                            command.id = uuidv4();
                            // add to commands to register
                            toRegister.push(command);
                            debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "loadedTopLevelCommandGuild"], command.name, command.guild));
                        } catch (e) {
                            error(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "error", "cannotLoad"], commandPath, e.stack));
                        }
                    }
                }
            }
            // subcommand finding time woo
            let commandsToSearch = [...toRegister];
            for (const command of commandsToSearch) {
                // check for subcommand folder
                let subcommandDir = resolve(dirname(command.filePath), command.name);
                // if no subcommand folder
                if (!existsSync(subcommandDir)) {
                    // but there's supposed to be one
                    if (command.role == CommandRoles.CONTAINER) {
                        warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "noExecute"], command.name));
                        toRegister = toRegister.filter(x => x.id != command.id);
                    }
                    continue;
                }
                // if the subcommand folder has an identity crisis
                if (!statSync(subcommandDir).isDirectory()) {
                    // but it's not meant to
                    if (command.role == CommandRoles.CONTAINER) {
                        warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "folderIdentityCrisis"], subcommandDir, command.name));
                        toRegister = toRegister.filter(x => x.id != command.id);
                    }
                    continue;
                }
                // ok so there is actually a subcommand folder, find subcommands
                let subcommandFilePaths = readdirSync(subcommandDir).map(x => resolve(subcommandDir, x)).filter(x => !statSync(x).isDirectory()).filter(x => extname(x) == ".js");
                if (!subcommandFilePaths.length &amp;&amp; command.role == CommandRoles.CONTAINER) {
                    // why did i bother to find the folder when there weren't any subcommands anyway
                    warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "noSubcommands"], command.name));
                    toRegister = toRegister.filter(x => x.id != command.id);
                    continue;
                }
                // subcommand groups are a thing but no one really cares about them
                if (subcommandFilePaths.some(x => /^group\./g.test(basename(x)))) {
                    // oh ok nvm someone cares about them
                    let groupDefininitionPaths = subcommandFilePaths.filter(x => /^group\./g.test(basename(x)));
                    // for each definition
                    for (const groupPath of groupDefininitionPaths) {
                        try {
                            // delete cached files
                            delete require.cache[require.resolve(groupPath)];
                            // import the group thing
                            /** @type {import("../types").Command} */
                            const groupDefinition = require(groupPath);
                            // ignore if no name
                            if (!groupDefinition.name) {
                                warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "noName"], groupPath));
                                continue;
                            }
                            // check for description
                            if (!groupDefinition.description) groupDefinition.description = "No description set.";
                            // link file path
                            groupDefinition.filePath = groupPath;
                            // assign a unique id
                            groupDefinition.id = uuidv4();
                            // set the role
                            groupDefinition.role = CommandRoles.SUBCOMMAND_CONTAINER;
                            // parent-child stuff
                            groupDefinition.parent = command.id;
                            if (!command.chilren) command.children = [];
                            command.children.push(groupDefinition.id);
                            // add to register list
                            toRegister.push(groupDefinition);
                            debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "loadedGroupDefinition"], command.name, groupDefinition.name));
                        } catch (e) {
                            error(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "error", "cannotLoad"], groupPath, e.stack));
                        }
                    }
                }

                // remove any subcommand group definitions from the list of subcommands
                subcommandFilePaths = subcommandFilePaths.filter(x => !/^group\./g.test(basename(x)));
                // test for paths with the 3 dot thing grouped subcommands need
                if (subcommandFilePaths.some(x => /(?&lt;!^group)\.[^.]+\.[^.]+/g.test(basename(x)))) {
                    let groupedSubcommandFilePaths = subcommandFilePaths.filter(x => /(?&lt;!^group)\.[^.]+\.[^.]+/g.test(basename(x)));
                    for (const groupedSubcommandPath of groupedSubcommandFilePaths) {
                        // get subcommand group name
                        let group = basename(groupedSubcommandPath).split(".")[0];
                        // ensure the group exists
                        if (!toRegister.find(x => x.role == CommandRoles.SUBCOMMAND_CONTAINER &amp;&amp; x.name == group)) {
                            warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "cannotFindGroup"], groupedSubcommandPath, group));
                            continue;
                        }
                        // right then actually load the thing
                        try {
                            // delete cached files
                            delete require.cache[require.resolve(groupedSubcommandPath)];
                            // importtttttttttttt
                            /** @type {import("../types").Command} */
                            const groupedSubcommand = require(groupedSubcommandPath);
                            // check for name
                            if (!groupedSubcommand.name)  {
                                warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "noName"], groupedSubcommandPath));
                                continue;
                            }
                            // set the command's role (for subcommand structure)
                            groupedSubcommand.role = CommandRoles.SUBCOMMAND;
                            // set description
                            if (!groupedSubcommand.description) groupedSubcommand.description = "No description set.";
                            // perms stuff
                            if (!groupedSubcommand.botPerms) groupedSubcommand.botPerms = [];
                            if (!groupedSubcommand.userPerms) groupedSubcommand.userPerms = [];
                            // check for options
                            if (!groupedSubcommand.options) groupedSubcommand.options = [];
                            // file path
                            groupedSubcommand.filePath = groupedSubcommandPath;
                            // unique id (for structure calculation later)
                            groupedSubcommand.id = uuidv4();

                            // parent-child stuff
                            /** @type {import("../types").Command} */
                            let parent = toRegister.find(x => x.role == CommandRoles.SUBCOMMAND_CONTAINER &amp;&amp; x.name == group);
                            groupedSubcommand.parent = parent.id;
                            if (!parent.children) parent.children = [];
                            parent.children.push(groupedSubcommand.id);

                            // add to register list
                            toRegister.push(groupedSubcommand);
                            debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "loadedGroupedCommand"], command.name, parent.name, groupedSubcommand.name));
                        } catch (e) {
                            error(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "error", "cannotLoad"], groupedSubcommandPath, e.stack));
                        }
                    }
                }

                // remove grouped commands from the list of subcommands
                subcommandFilePaths = subcommandFilePaths.filter(x => !/(?&lt;!^group)\.[^.]+\.[^.]+/g.test(basename(x)));

                // anyway load the subcommands
                for (const subcommandPath of subcommandFilePaths) {
                    try {
                        // delete cached files
                        delete require.cache[require.resolve(subcommandPath)];
                        /** @type {import("../types").Command} */
                        const subcommand = require(subcommandPath);
                        // check for a command name
                        if (!subcommand.name) {
                            warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "noName"], subcommandPath));
                            continue;
                        }
                        // set the command's role (for subcommand structure)
                        subcommand.role = CommandRoles.SUBCOMMAND;
                        // set description
                        if (!subcommand.description) subcommand.description = "No description set.";
                        // perms stuff
                        if (!subcommand.botPerms) subcommand.botPerms = [];
                        if (!subcommand.userPerms) subcommand.userPerms = [];
                        // check for options
                        if (!subcommand.options) subcommand.options = [];
                        // file path
                        subcommand.filePath = subcommandPath;
                        // unique id (for structure calculation later)
                        subcommand.id = uuidv4();

                        // parent-child stuff for structure
                        subcommand.parent = command.id;
                        if (!command.children) command.children = [];
                        command.children.push(subcommand.id);

                        // add to commands to register
                        toRegister.push(subcommand);
                        debug(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "debug", "loadedSubcommand"], command.name, subcommand.name));
                    } catch (e) {
                        error(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "error", "cannotLoad"], subcommandPath, e.stack));
                    }
                }
            }
            // now actually register them
            toRegister.forEach(x => CommandHandler.commands.set(x.id, x));
        }
        info(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "info", "loadedCommands"]));

        return CommandHandler;
    }

    /**
     * Get a global command from a path.
     * @param  {...String} path The path of the command.
     * @returns {import("../types").Command} The command.
     */
    static getCommand(...path) {
        // return nothing if no path
        if (!path.length) return;
        let commandsToSearch = CommandHandler.commands.filter(x => !x.guild);
        // find top level command
        /** @type {import("../types").Command} */
        let firstLevel = commandsToSearch.find(x => x.name == path[0] &amp;&amp; (x.role == CommandRoles.COMMAND || x.role == CommandRoles.CONTAINER));
        // return nothing if not found
        if (!firstLevel) return;
        // return if nothing else to search for
        if (!path[1]) return firstLevel;
        // else carry on searching
        /** @type {import("../types").Command} */
        let secondLevel = commandsToSearch.find(x => x.name == path[1] &amp;&amp; x.parent == firstLevel.id);
        // return nothing if not found
        if (!secondLevel) return;
        // return if nothing else to search for
        if (!path[2]) return secondLevel;
        // else carry on searching
        /** @type {import("../types").Command} */
        let thirdLevel = commandsToSearch.find(x => x.name == path[2] &amp;&amp; x.parent == secondLevel.id);
        return thirdLevel;
    }

    /**
     * Get a guild specific command from a path.
     * @param {string} guildID The guild's ID.
     * @param  {...any} path The path of the command.
     * @returns {import("../types").Command} The command.
     */
    static getGuildCommand(guildID, ...path) {
        // return nothing if no path
        if (!path.length) return;
        let commandsToSearch = CommandHandler.commands.filter(x => x.guild == guildID);
        // find top level command
        /** @type {import("../types").Command} */
        let firstLevel = commandsToSearch.find(x => x.name == path[0] &amp;&amp; (x.role == CommandRoles.COMMAND || x.role == CommandRoles.CONTAINER));
        // return nothing if not found
        if (!firstLevel) return;
        // return if nothing else to search for
        if (!path[1]) return firstLevel;
        // else carry on searching
        /** @type {import("../types").Command} */
        let secondLevel = commandsToSearch.find(x => x.name == path[1] &amp;&amp; x.parent == firstLevel.id);
        // return nothing if not found
        if (!secondLevel) return;
        // return if nothing else to search for
        if (!path[2]) return secondLevel;
        // else carry on searching
        /** @type {import("../types").Command} */
        let thirdLevel = commandsToSearch.find(x => x.name == path[2] &amp;&amp; x.parent == secondLevel.id);
        return thirdLevel;
    }

    /**
     * Generate the command structure in order to register commands with Discord.
     * @param {import("discord.js").Snowflake=} guildID The ID of the guild to generate a structure for.
     * @returns {import("discord-api-types/v10").RESTPostAPIApplicationCommandsJSONBody} The structure.
     * @static
     */
    static generateStructure(guildID) {
        // if no client attached
        if (!CommandHandler.#client) throw new Error(getText(undefined, ["generic", "errors", "noClient"]));

        // get commands to generate structure for
        let commandsToUse = guildID ? CommandHandler.commands.filter(x => x.guild == guildID) : CommandHandler.commands.filter(x => !x.guild);
        // return if no commands to generate structure for
        if (!commandsToUse.size) return [];
        // output array
        let structure = [];
        // get top level commands
        let topLevel = commandsToUse.filter(x => x.role == CommandRoles.COMMAND || x.role == CommandRoles.CONTAINER);
        // generate each command
        topLevel.forEach(command => {
            // set basic command info
            let toPush = new SlashCommandBuilder()
                .setName(command.name)
                .setDescription(command.name)
                .setNameLocalizations(getCommandLocalisations(command).name)
                .setDescriptionLocalizations(getCommandLocalisations(command).description);
            // set options
            if (command.options?.length) {
                // for each option
                command.options.forEach(option => {
                    // determine the option type + the function to use
                    switch (option.type) {
                        case CommandOptionTypes.STRING:
                        case CommandOptionTypes.INTEGER:
                        case CommandOptionTypes.NUMBER:
                            toPush[`add${Object.keys(CommandOptionTypes)[option.type].charAt(0) + Object.keys(CommandOptionTypes)[option.type].slice(1).toLowerCase()}Option`](
                                // actually add the option
                                x => {
                                    x.setName(option.name)
                                    .setDescription(option.description)
                                    .setRequired(option.required)
                                    .setNameLocalizations(getCommandOptionLocalisations(command)[option.name]?.name || {})
                                    .setDescriptionLocalizations(getCommandOptionLocalisations(command)[option.name]?.description || {});
                                    if (option.choices?.length) x.setChoices(...option.choices);
                                    return x;
                                }
                            );
                            break;
                        default:
                            toPush[`add${Object.keys(CommandOptionTypes)[option.type].charAt(0) + Object.keys(CommandOptionTypes)[option.type].slice(1).toLowerCase()}Option`](
                                // actually add the option
                                x => x.setName(option.name).setDescription(option.description).setRequired(option.required)
                            );
                    }
                });
            }
            // deal with children
            if (command.children?.length) {
                for (const childID of command.children) {
                    // find the child object
                    let child = CommandHandler.commands.find(x => x.id == childID);
                    // ignore if there is no child
                    if (!child) continue;
                    // else determine type
                    switch (child.role) {
                        case CommandRoles.SUBCOMMAND: // (normal subcommand)
                            // set basic command info
                            let subcommand = new SlashCommandSubcommandBuilder()
                                .setName(child.name)
                                .setDescription(child.description)
                                .setNameLocalizations(getCommandLocalisations(child).name)
                                .setDescriptionLocalizations(getCommandLocalisations(child).description);
                            // set options
                            if (child.options?.length) {
                                // for each option
                                child.options.forEach(option => {
                                    // determine the option type + the function to use
                                    switch (option.type) {
                                        case CommandOptionTypes.STRING:
                                        case CommandOptionTypes.INTEGER:
                                        case CommandOptionTypes.NUMBER:
                                            subcommand[`add${Object.keys(CommandOptionTypes)[option.type].charAt(0) + Object.keys(CommandOptionTypes)[option.type].slice(1).toLowerCase()}Option`](
                                                // actually add the option
                                                x => {
                                                    x.setName(option.name)
                                                    .setDescription(option.description)
                                                    .setRequired(option.required)
                                                    .setNameLocalizations(getCommandOptionLocalisations(child)[option.name]?.name || {})
                                                    .setDescriptionLocalizations(getCommandOptionLocalisations(child)[option.name]?.description || {});
                                                    if (option.choices?.length) x.setChoices(...option.choices);
                                                    return x;
                                                }
                                            );
                                            break;
                                        default:
                                            subcommand[`add${Object.keys(CommandOptionTypes)[option.type].charAt(0) + Object.keys(CommandOptionTypes)[option.type].slice(1).toLowerCase()}Option`](
                                                // actually add the option
                                                x => x.setName(option.name).setDescription(option.description).setRequired(option.required)
                                            );
                                    }
                                });
                            }
                            // add the subcommand to the command
                            toPush.addSubcommand(subcommand);
                            break;
                        case CommandRoles.SUBCOMMAND_CONTAINER: // (subcommand group def)
                            // set basic info
                            let subcommandGroup = new SlashCommandSubcommandGroupBuilder()
                                .setName(child.name)
                                .setDescription(child.description)
                                .setNameLocalizations(getCommandLocalisations(child).name)
                                .setDescriptionLocalizations(getCommandLocalisations(child).description);
                            // ignore if empty group
                            if (!child.children?.length) continue;
                            for (const childChildID of child.children) {
                                // get the child child
                                let childChild = CommandHandler.commands.find(x => x.id == childChildID);
                                // ignore if child child does not exist
                                if (!childChild) continue;
                                // set basic command info
                                let subcommand = new SlashCommandSubcommandBuilder()
                                    .setName(childChild.name)
                                    .setDescription(childChild.description)
                                    .setNameLocalizations(getCommandLocalisations(childChild).name)
                                    .setDescriptionLocalizations(getCommandLocalisations(childChild).description);
                                // set options
                                if (childChild.options?.length) {
                                    // for each option
                                    childChild.options.forEach(option => {
                                        // determine the option type + the function to use
                                    switch (option.type) {
                                        case CommandOptionTypes.STRING:
                                        case CommandOptionTypes.INTEGER:
                                        case CommandOptionTypes.NUMBER:
                                            subcommand[`add${Object.keys(CommandOptionTypes)[option.type].charAt(0) + Object.keys(CommandOptionTypes)[option.type].slice(1).toLowerCase()}Option`](
                                                // actually add the option
                                                x => {
                                                    x.setName(option.name)
                                                    .setDescription(option.description)
                                                    .setRequired(option.required)
                                                    .setNameLocalizations(getCommandOptionLocalisations(childChild)[option.name]?.name || {})
                                                    .setDescriptionLocalizations(getCommandOptionLocalisations(childChild)[option.name]?.description || {});
                                                    if (option.choices?.length) x.setChoices(...option.choices);
                                                    return x;
                                                }
                                            );
                                            break;
                                        default:
                                            subcommand[`add${Object.keys(CommandOptionTypes)[option.type].charAt(0) + Object.keys(CommandOptionTypes)[option.type].slice(1).toLowerCase()}Option`](
                                                // actually add the option
                                                x => x.setName(option.name).setDescription(option.description).setRequired(option.required)
                                            );
                                    }
                                    });
                                }
                                // add to subcommand group
                                subcommandGroup.addSubcommand(subcommand);
                            }
                            // add subcommand group to command
                            toPush.addSubcommandGroup(subcommandGroup);
                            break;
                        default:
                            warn(getText(CommandHandler.#client.consoleLang, ["handlers", "command", "warn", "invalidRole"], command.name, child.name, child.role));
                            continue;
                    }
                }
            }
            // push command to structure
            structure.push(toPush);
        });

        // convert structure to JSON
        structure = structure.map(x => x.toJSON());

        return structure;
    }
}

module.exports = CommandHandler;</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"CommandHandler","link":"<a href=\"CommandHandler.html\">CommandHandler</a>"},{"title":"CommandHandler.addCommandDirectory","link":"<a href=\"CommandHandler.html#.addCommandDirectory\">CommandHandler &rtrif; addCommandDirectory</a>"},{"title":"CommandHandler.attachClient","link":"<a href=\"CommandHandler.html#.attachClient\">CommandHandler &rtrif; attachClient</a>"},{"title":"CommandHandler.generateStructure","link":"<a href=\"CommandHandler.html#.generateStructure\">CommandHandler &rtrif; generateStructure</a>"},{"title":"CommandHandler.getCommand","link":"<a href=\"CommandHandler.html#.getCommand\">CommandHandler &rtrif; getCommand</a>"},{"title":"CommandHandler.getGuildCommand","link":"<a href=\"CommandHandler.html#.getGuildCommand\">CommandHandler &rtrif; getGuildCommand</a>"},{"title":"CommandHandler.loadCommands","link":"<a href=\"CommandHandler.html#.loadCommands\">CommandHandler &rtrif; loadCommands</a>"},{"title":"CommandHandler.removeCommandDirectory","link":"<a href=\"CommandHandler.html#.removeCommandDirectory\">CommandHandler &rtrif; removeCommandDirectory</a>"},{"title":"DatabaseHandler","link":"<a href=\"DatabaseHandler.html\">DatabaseHandler</a>"},{"title":"DatabaseHandler.init","link":"<a href=\"DatabaseHandler.html#.init\">DatabaseHandler &rtrif; init</a>"},{"title":"DatabaseHandler.operation","link":"<a href=\"DatabaseHandler.html#.operation\">DatabaseHandler &rtrif; operation</a>"},{"title":"EventHandler","link":"<a href=\"EventHandler.html\">EventHandler</a>"},{"title":"EventHandler.addEventDirectory","link":"<a href=\"EventHandler.html#.addEventDirectory\">EventHandler &rtrif; addEventDirectory</a>"},{"title":"EventHandler.attachClient","link":"<a href=\"EventHandler.html#.attachClient\">EventHandler &rtrif; attachClient</a>"},{"title":"EventHandler.loadEvents","link":"<a href=\"EventHandler.html#.loadEvents\">EventHandler &rtrif; loadEvents</a>"},{"title":"EventHandler.removeEventDirectory","link":"<a href=\"EventHandler.html#.removeEventDirectory\">EventHandler &rtrif; removeEventDirectory</a>"},{"title":"InteractionHandler","link":"<a href=\"InteractionHandler.html\">InteractionHandler</a>"},{"title":"InteractionHandler.processInteraction","link":"<a href=\"InteractionHandler.html#.processInteraction\">InteractionHandler &rtrif; processInteraction</a>"},{"title":"LanguageHandler","link":"<a href=\"LanguageHandler.html\">LanguageHandler</a>"},{"title":"LanguageHandler.addLanguageFolder","link":"<a href=\"LanguageHandler.html#.addLanguageFolder\">LanguageHandler &rtrif; addLanguageFolder</a>"},{"title":"LanguageHandler.getCommandLocalisations","link":"<a href=\"LanguageHandler.html#.getCommandLocalisations\">LanguageHandler &rtrif; getCommandLocalisations</a>"},{"title":"LanguageHandler.getCommandOptionLocalisations","link":"<a href=\"LanguageHandler.html#.getCommandOptionLocalisations\">LanguageHandler &rtrif; getCommandOptionLocalisations</a>"},{"title":"LanguageHandler.getLocalisation","link":"<a href=\"LanguageHandler.html#.getLocalisation\">LanguageHandler &rtrif; getLocalisation</a>"},{"title":"LanguageHandler.getLocalisationFromAPILocale","link":"<a href=\"LanguageHandler.html#.getLocalisationFromAPILocale\">LanguageHandler &rtrif; getLocalisationFromAPILocale</a>"},{"title":"LanguageHandler.loadAllLanguages","link":"<a href=\"LanguageHandler.html#.loadAllLanguages\">LanguageHandler &rtrif; loadAllLanguages</a>"},{"title":"LanguageHandler.loadLanguageFile","link":"<a href=\"LanguageHandler.html#.loadLanguageFile\">LanguageHandler &rtrif; loadLanguageFile</a>"},{"title":"LoggingHandler","link":"<a href=\"LoggingHandler.html\">LoggingHandler</a>"},{"title":"LoggingHandler.createLogger","link":"<a href=\"LoggingHandler.html#.createLogger\">LoggingHandler &rtrif; createLogger</a>"},{"title":"Util","link":"<a href=\"Util.html\">Util</a>"},{"title":"Util.arrayToConsoleList","link":"<a href=\"Util.html#.arrayToConsoleList\">Util &rtrif; arrayToConsoleList</a>"},{"title":"Util.ownerCheck","link":"<a href=\"Util.html#.ownerCheck\">Util &rtrif; ownerCheck</a>"},{"title":"Util.walk","link":"<a href=\"Util.html#.walk\">Util &rtrif; walk</a>"},{"title":"Command","link":"<a href=\"global.html#Command\">Command</a>"},{"title":"CommandExecute","link":"<a href=\"global.html#CommandExecute\">CommandExecute</a>"},{"title":"CommandLocalisationObject","link":"<a href=\"global.html#CommandLocalisationObject\">CommandLocalisationObject</a>"},{"title":"CommandOption","link":"<a href=\"global.html#CommandOption\">CommandOption</a>"},{"title":"CommandOptionChoice","link":"<a href=\"global.html#CommandOptionChoice\">CommandOptionChoice</a>"},{"title":"CommandOptionLocalisationObject","link":"<a href=\"global.html#CommandOptionLocalisationObject\">CommandOptionLocalisationObject</a>"},{"title":"CommandOptionType","link":"<a href=\"global.html#CommandOptionType\">CommandOptionType</a>"},{"title":"CommandOptionTypes","link":"<a href=\"global.html#CommandOptionTypes\">CommandOptionTypes</a>"},{"title":"CommandRole","link":"<a href=\"global.html#CommandRole\">CommandRole</a>"},{"title":"CommandRoles","link":"<a href=\"global.html#CommandRoles\">CommandRoles</a>"},{"title":"CommandSettings","link":"<a href=\"global.html#CommandSettings\">CommandSettings</a>"},{"title":"CommandType","link":"<a href=\"global.html#CommandType\">CommandType</a>"},{"title":"CommandTypes","link":"<a href=\"global.html#CommandTypes\">CommandTypes</a>"},{"title":"Event","link":"<a href=\"global.html#Event\">Event</a>"},{"title":"EventDebounceSettingsObject","link":"<a href=\"global.html#EventDebounceSettingsObject\">EventDebounceSettingsObject</a>"},{"title":"EventSettingsObject","link":"<a href=\"global.html#EventSettingsObject\">EventSettingsObject</a>"},{"title":"ISOLangCode","link":"<a href=\"global.html#ISOLangCode\">ISOLangCode</a>"},{"title":"Language","link":"<a href=\"global.html#Language\">Language</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>
